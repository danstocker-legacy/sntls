<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: data/OrderedStringList.js</title>
    
    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">
    
    <h1 class="page-title">Source: data/OrderedStringList.js</h1>
    
    


    
    <section>
        <article>
            <pre class="prettyprint source"><code>/*global dessert, troop, sntls */
troop.postpone(sntls, 'OrderedStringList', function () {
    "use strict";

    /**
     * Instantiates class.
     * @name sntls.OrderedStringList.create
     * @function
     * @param {string[]} [items] Initial values
     * @returns {sntls.OrderedStringList}
     */

    /**
     * Ordered list extended with string-specific fast, prefix-based search.
     * @class sntls.OrderedStringList
     * @extends sntls.OrderedList
     */
    sntls.OrderedStringList = sntls.OrderedList.extend()
        .addPrivateMethods(/** @lends sntls.OrderedStringList */{
            /**
             * Calculates range search end value for prefix search based on start value.
             * Increments char code on the string's last character.
             * @param {string} startValue
             * @returns {String} Calculated end value
             * @private
             */
            _getEndValue: function (startValue) {
                return startValue.slice(0, -1) + String.fromCharCode(startValue.substr(-1).charCodeAt(0) + 1);
            },

            /**
             * Returns lowest value string that is higher than the input.
             * @param {string} startValue
             * @returns {string}
             * @private
             */
            _getNextValue: function (startValue) {
                return startValue + String.fromCharCode(0);
            }
        })
        .addMethods(/** @lends sntls.OrderedStringList# */{
            /**
             * Retrieves items from the list matching the specified prefix.
             * @example
             * var osl = sntls.OrderedStringList(['hi', 'hello', 'hire', 'foo']);
             * osl.getRangeByPrefix('hi') // ['hi', 'hire']
             * osl.getRangeByPrefix('h') // ['hello', 'hi', 'hire']
             * @param {string} prefix Prefix to be matched by list items.
             * @param {boolean} [excludeOriginal=false] Whether to exclude `prefix` from the results
             * @param {number} [offset=0] Number of items to skip at start.
             * @param {number} [limit=Infinity] Number of items to fetch at most.
             * @returns {string[]} Sorted array of matches.
             */
            getRangeByPrefix: function (prefix, excludeOriginal, offset, limit) {
                dessert
                    .assert(typeof prefix === 'string' && prefix.length > 0, "Empty prefix")
                    .isBooleanOptional(excludeOriginal);

                var startValue = excludeOriginal ?
                        this._getNextValue(prefix) :
                        prefix,
                    endValue = this._getEndValue(prefix);

                return this.getRange(startValue, endValue, offset, limit);
            },

            /**
             * Retrieves items from the list matching the specified prefix, wrapped in a hash.
             * @param {string} prefix Prefix to be matched by list items.
             * @param {boolean} [excludeOriginal=false] Whether to exclude `prefix` from the results
             * @param {number} [offset=0] Number of items to skip at start.
             * @param {number} [limit=Infinity] Number of items to fetch at most.
             * @returns {sntls.Hash}
             * @see sntls.OrderedList#getRange
             */
            getRangeByPrefixAsHash: function (prefix, excludeOriginal, offset, limit) {
                var range = this.getRangeByPrefix.apply(this, arguments);
                return sntls.Hash.create(range);
            },

            /**
             * Removes all occurrences of a specific string from the list.
             * @example
             * var osl = sntls.OrderedStringList(['hi', 'hello', 'hire', 'hi', 'foo']);
             * osl.removeAll('hi').items // ['hello', 'hire', 'foo']
             * @param {string} value String value to be removed from list.
             * @returns {sntls.OrderedStringList}
             */
            removeEvery: function (value) {
                dessert.isString(value);
                this.removeRange(value, this._getNextValue(value));
                return this;
            }
        });
});

(function () {
    "use strict";

    sntls.Hash.addMethods(/** @lends sntls.Hash# */{
        /**
         * Reinterprets hash as ordered string list.
         * @returns {sntls.OrderedStringList}
         */
        toOrderedStringList: function () {
            return sntls.OrderedStringList.create(this.items);
        }
    });
}());
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Classes</h3><ul><li><a href="sntls.ArrayCollection.html">ArrayCollection</a></li><li><a href="sntls.Collection.html">Collection</a></li><li><a href="sntls.DateCollection.html">DateCollection</a></li><li><a href="sntls.Dictionary.html">Dictionary</a></li><li><a href="sntls.Documented.html">Documented</a></li><li><a href="sntls.Hash.html">Hash</a></li><li><a href="sntls.IterativeTreeWalker.html">IterativeTreeWalker</a></li><li><a href="sntls.JournalingCollection.html">JournalingCollection</a></li><li><a href="sntls.Lineage.html">Lineage</a></li><li><a href="sntls.Managed.html">Managed</a></li><li><a href="sntls.OrderedList.html">OrderedList</a></li><li><a href="sntls.OrderedStringList.html">OrderedStringList</a></li><li><a href="sntls.Path.html">Path</a></li><li><a href="sntls.Profile.html">Profile</a></li><li><a href="sntls.ProfileCollection.html">ProfileCollection</a></li><li><a href="sntls.Profiled.html">Profiled</a></li><li><a href="sntls.Progenitor.html">Progenitor</a></li><li><a href="sntls.Query.html">Query</a></li><li><a href="sntls.QueryPattern.html">QueryPattern</a></li><li><a href="sntls.QueryPatternCollection.html">QueryPatternCollection</a></li><li><a href="sntls.RecursiveTreeWalker.html">RecursiveTreeWalker</a></li><li><a href="sntls.Stateful.html">Stateful</a></li><li><a href="sntls.StateMatrix.html">StateMatrix</a></li><li><a href="sntls.StateMatrixCollection.html">StateMatrixCollection</a></li><li><a href="sntls.StringCollection.html">StringCollection</a></li><li><a href="sntls.StringDictionary.html">StringDictionary</a></li><li><a href="sntls.Tree.html">Tree</a></li><li><a href="sntls.TreeWalker.html">TreeWalker</a></li><li><a href="sntls.Utils.html">Utils</a></li></ul><h3>Namespaces</h3><ul><li><a href="sntls.html">sntls</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.2.0-dev</a> on Sun Aug 25 2013 23:10:42 GMT+0200 (CEST)
</footer>

<script> prettyPrint(); </script>
</body>
</html>
